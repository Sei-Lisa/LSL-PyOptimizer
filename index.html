<!DOCTYPE html>
<html><head>
<title>LSL PyOptimizer project</title>
<style type="text/css">
body { background:#506c80; font-family:Verdana, Bitstream Vera Sans, sans-serif; font-size:10pt; line-height:1.5; }
a { text-decoration:none;color:#004090; }
a:hover { text-decoration:underline; }
a:visited { color:#9000c0; }
pre, code { background:#ecf0ff; padding:1px; border: solid 1px #c0dcee; }
pre code { border: none; }
pre { margin: 0px 4px; padding:4px 1em 4px 0.2em; white-space:pre-wrap; }
pre code { padding: 0px; }
pre span { padding-left: 0.8em; }
i em { font-style: normal; }
h1 { background: #2080C0; color: white; padding:25px 5% 8px; margin: 4% 7% 0px; }
#textcontainer { margin: 0px 7% 1000px; padding: 30px 13% 30px 5%; background:#dee6ff; word-wrap:break-word; }
</style>
</head><body>

<h1><a id="lsl-pyoptimizer"></a>LSL PyOptimizer</h1>

<div id="textcontainer">

<h2>NEW! Online version</h2>

<p>There is now an online version that you can try, here: <a href="online.php?">LSL-PyOptimizer online</a></p>

<h2><a id="introduction"></a>Introduction</h2>

<p><b>LSL PyOptimizer</b> is a LSL2 script optimizer written in Python 2.7. Currently it only supports code memory optimization (no speed optimization), only for Mono (no LSO), and only for the Second Life flavour of LSL (no OpenSim etc.).</p>

<p>The original LSL compiler does not do any optimizations whatsoever. Either the programmer does the optimization, or the scripts take more memory than necessary when writing something as simple as <code>a = -1;</code> (yes, the sign takes code memory!).</p>

<p>Given the 64K total code+data memory limit that applies to Mono scripts, this becomes a problem, leading to either difficult to read scripts, if optimized by hand, or in case of large scripts, to code taking valuable memory that could be used to embed more code or data.</p>

<p>The aim of this program is to act as a filter that performs the optimizations automatically, letting the programmer focus on writing readable code.</p>

<p>It also implements several syntax extensions to help improving the readability of scripts and the productivity of the programmer. It works well when combined with a C preprocessor such as <em>Boost::Wave</em> (the one embedded in Firestorm and other TPVs) or <em>GNU cpp</em>.</p>

<p>Firestorm does already incorporate an optimizer, but it is limited to removing unused global variables and functions, and does so by simple string analysis, not by syntactic analysis (e.g. if a local variable with the same name as a global is defined, the global isn't optimized out even if not used). In contrast, the program presented here does full syntax analysis and implements many more optimizations, including removing unused locals, simplifying many expressions, removing dead code, and more.</p>

<h2><a id="status"></a>Status</h2>

<p>It is now in the beta stage. Command line options are still subject to change, and new features may be added without notice. Please help by reporting any bugs you find, using the <a href="https://github.com/Sei-Lisa/LSL-PyOptimizer/issues">project's issue tracker at GitHub</a>.</p>

<h2><a id="features"></a>Features</h2>

<p><a href="#syntax-extensions">Syntax extensions supported:</a></p>

<ul>
<li><a href="#extensions-break-and-continue"><code>break</code> and <code>continue</code> statements.</a></li>
<li><a href="#extensions-expressions-in-globals">Expressions in globals.</a></li>
<li><a href="#extensions-extended-assignment-operators">Extended assignment operators</a> <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>.</li>
<li><a href="#extensions-concatenation-of-key-and-string">Concatenation of key and string.</a></li>
<li><a href="#extensions-c-like-string-juxtaposition">C-like string juxtaposition</a>: "str1" "str2" produces "str1str2".</li>
<li><a href="#extensions-type-cast-extension">Allow type-cast of unary expressions that are not postfix</a>, e.g. <code>(string)++x</code>.</li>
<li><a href="#extensions-multiple-labels-with-the-same-name">Allow multiple labels with the same name in the same function.</a></li>
<li><a href="#extensions-switch-statements"><code>switch()</code> statements</a>, for compatibility with Firestorm.</li>
<li><a href="#extensions-lazy-lists">Lazy list syntax</a> (<code>identifier[index]</code>), for compatibility with Firestorm.</li>
<li><a href="#extensions-allow-dup-fn">Allow duplicate function definitions</a>, for compatibility with Firestorm.</li>
<li>Invoke the preprocessor on its own, providing defaults for the GNU C preprocessor <code>cpp</code> and for <a href="http://mcpp.sourceforge.net/">mcpp</a> (since 0.1.3alpha).</li>
<li>Interpret <a href="#extensions-preproc-cmds"><code>#pragma</code> and <code>#line</code> preprocessor directives</a> (0.2.1beta).</li>
<li><a href="#extensions-inlining">Manual inlining of functions</a> (0.3.0beta).
</ul>

<p><a href="#optimizations">Optimizations supported:</a></p>

<ul>
<li><a href="#optimizations-constant-folding-and-expression-simplification">Constant folding, expression and statement simplification</a>.</li>
<li><a href="#optimizations-dead-code-removal">Dead code removal</a>, including unused functions and global and local variables.</li>
<li><a href="#optimizations-shrinking-identifiers">Shrinking identifiers.</a></li>
<li><a href="#optimizations-floats">Floats to integers where possible.</a></li>
<li><a href="#optimizations-signs">Signs in numbers.</a></li>
<li><a href="#optimizations-string-constant-folding">String constant concatenation.</a>
</ul>

<p>The next sections explain these features in detail.</p>

<h2><a id="Download"></a>Download</h2>

<p>The project is hosted on GitHub. The latest version is available at: <a href="https://github.com/Sei-Lisa/LSL-PyOptimizer">https://github.com/Sei-Lisa/LSL-PyOptimizer</a></p>

<p>In order to run the program, you need <a href="https://www.python.org/downloads/">Python</a> installed. It should work with both Python 2.7 and Python 3.x. Note that Python 3.x support is still in beta; if you run into any error while using it, please file a <a href="https://github.com/Sei-Lisa/LSL-PyOptimizer/issues">report</a>.</p>

<h2><a id="also-on-this-page"></a>Also on this page</h2>

<ul>
<li><a href="#using-the-program">Using the program</a></li>
<li><a href="#other-future-plans">Other future plans</a></li>
<li><a href="#license">License</a></li>
<li><a href="#author">Author</a></li>
</ul>

<hr>

<h2><a id="syntax-extensions"></a>Syntax extensions</h2>

<h3><a id="extensions-break-and-continue"></a>
<code>break</code> and <code>continue</code>
</h3>

<p>Support for <code>break</code> and <code>continue</code> statements, working as their C equivalents. It also supports <code>break n;</code> and <code>continue n;</code> for a constant integer <code>n</code> which indicates the number of nested loops to exit from (in the case of <code>break</code>) or to <code>continue</code> at. The default <code>n</code> when not specified is 1, meaning to break or continue at the current loop.</p>

<h3><a id="extensions-expressions-in-globals"></a>Expressions in globals</h3>

<p>Allow arbitrary expressions in globals, as long as they resolve to a single constant. The optimizer will evaluate the expression and substitute the result in the final script. For example, you can have a line like:</p>

<pre><code><span>    float a = llPow(llSin(40*DEG_TO_RAD), 2);</span>
</code></pre>

<p>in the globals section, and the optimizer will output the line:</p>

<pre><code><span>    float a = 0.41317588;</span>
</code></pre>

<p>instead. Needs constant folding optimization to be enabled. If the expression does not resolve to a constant, a warning will be emitted, and the compilation will fail at that line.</p>

<h3><a id="extensions-extended-assignment-operators"></a>Extended assignment operators</h3>

<p>C-like <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code> assignment operator support.</p>

<h3><a id="extensions-concatenation-of-key-and-string"></a>Concatenation of key and string</h3>

<p>In LSL, keys are automatically cast to string in most cases. For example:</p>

<pre><code><span>    llOwnerSay(llGetOwner());</span>
</code></pre>

<p>works perfectly. However, one prominent case where that does not happen automatically is in string concatenation. Confusingly, while the above works, this doesn't:</p>

<pre><code><span>    llOwnerSay("Your key is: " + llGetOwner());</span>
</code></pre>

<p>and instead produces a type mismatch error. This syntax extension allows you to concatenate strings and keys, making the type cast transparent.</p>

<h3><a id="extensions-c-like-string-juxtaposition"></a>C-like string juxtaposition.</h3>

<p>For example <code>"a" "b"</code> resolves to the string <code>"ab"</code>. Very useful when combined with preprocessor macros, for not needing to add strings together to form a larger string. For example:</p>

<pre><code><span>#define VERSION "1.13"</span>
<span>#define REVISION "b"</span>
<span>...</span>
<span>llOwnerSay("Program version " VERSION</span>
<span>           ", revision " REVISION);</span>
</code></pre>

<p>or even</p>

<pre><code><span>#define VERSION 1.13</span>
<span>#define REVISION b</span>
<span>#define VERBATIM_STRINGIFY(...) #__VA_ARGS__</span>
<span>#define STRINGIFY(...) VERBATIM_STRINGIFY(__VA_ARGS__)</span>
<span>...</span>
<span>llOwnerSay("Program version " STRINGIFY(VERSION)</span>
<span>           ", revision " STRINGIFY(REVISION));</span>
</code></pre>

<p>will resolve to:</p>

<pre><code><span>llOwnerSay("Program version 1.13, revision b");</span>
</code></pre>

<p>instead of something like</p>

<pre><code><span>llOwnerSay("Program version " + "1.13" + ", revision " + "b");</span>
</code></pre>

<p>The latter can also be resolved by the optimizer, but by default that optimization is disabled as it can be counter-productive (see <a href="#optimizations-string-constant-folding">String constant concatenation</a> below for more information).</p>

<h3><a id="extensions-type-cast-extension"></a>Type-cast extension</h3>

<p>For some reason, LSL only allows postfix expressions after a type cast. This feature extends the syntax to allow prefix expressions as well. This means that you can write e.g. <code>(string)(integer)a</code> instead of <code>(string)((integer)a)</code>, or <code>(string)++x</code> instead of <code>(string)(++x)</code>, sparing you from having to enter the extra parentheses.</p>

<h3><a id="extensions-multiple-labels-with-the-same-name"></a>Multiple labels with the same name</h3>

<p>Allows duplicate labels obeying the LSL scope rules. This one is tricky to understand. In LSL, syntax-wise, label identifiers obey the same scope rules as variables: when opening a new block, the labels defined inside it are invisible to any of the outer blocks. This means that you can have labels with the same name in different blocks, just like you can have variables with the same name in different blocks.</p>

<p>For example, you can have:</p>

<pre><code><span>default</span>
<span>{</span>
<span>    state_entry()</span>
<span>    {</span>
<span>        {</span>
<span>            integer i;</span>
<span>            @label1;</span>
<span>        }</span>
<span>        {</span>
<span>            integer i;</span>
<span>            @label1;</span>
<span>        }</span>
<span>    }</span>
<span>}</span>
</code></pre>

<p>Just as the variables, the labels are visible only within their own blocks or any nested block inside them. Unlike variables, labels are also visible if they are declared <em>after</em> the <code>jump</code> instruction that uses them, as long as it's within a block that encloses the label.</p>

<p>However, that's only the theory, The compiler is prepared to work like that, but when there is more than one label with the same name, the underlying assembler only jumps to the last label (in the case of LSO) or fails and doesn't let the script to be saved (in the case of Mono).</p>

<p>This syntax extension fixes that situation by renaming the labels in the output, to give each a different name and allow Mono scripts to be saved, making the compiler work as intended.</p>

<p>Again, one use is in preprocessor macros. Consider this example:</p>

<pre><code><span>#define DO {@dowhile;</span>
<span>#define WHILE(expr) if (expr) jump dowhile;}</span>
</code></pre>

<p>Without this option, you would only be able to have one <code>DO...WHILE()</code> loop per function.</p>

<h3><a id="extensions-preproc-cmds"></a>#pragma and #line</h3>

<p>The optimizer option <code>ProcessPre</code> enables processing of certain preprocessor directives that control compilation. Only <code>#pragma</code> and <code>#line</code> are supported for now. Typically these directives pass through the preprocessor unchanged (not always; see note below about <em>GNU cpp</em> and <code>#line</code>), so they will reach the optimizer when a preprocessor is used. The rest of preprocessor directives will be ignored.</p>

<p>The <code>#line</code> directive is not supposed to be used by the programmer. C/C++ preprocessors, including <em>Boost::Wave</em>, <em>mcpp</em> and <em>GNU cpp</em>, automatically generate them whenever the lines in the original file lose synchronization with the preprocessor's output, in order to keep track of which original line produced a certain output line, for error reporting and debugging purposes. As of version 0.2.2beta, this directive does indeed track which input line generated a certain output line, generating errors with a line number that refers to the original file rather than the preprocessed/optimized file, and including the name of the file where the error was found when it differs from the initial source.</p>

<p><code>#pragma</code> is a special C preprocessor directive that allows compilers to extend the language with certain options. In the case of this optimizer, the <code>#pragma</code> directive is used to enable/disable on the fly the parsing options and extensions, taking precedence over all others. Even <code>ProcessPre</code> itself can be disabled (it can't be enabled this way because when disabled, <code>#pragma</code> directives aren't processed).</p>

<p>To use this feature, type the command like this:</p>

<pre><code><span><b>#pragma OPT</b> [+/-]<i>option1</i>[,[+/-]<i>option2</i>,...]</span>
</code></pre>

<p>Note that it's important that OPT is in upper case. The options list is not case sensitive, but it can't have any spaces.</p>

<p>For example, this code activates the <a href="#extensions-break-and-continue"><code>break</code> and <code>continue</code> statements extension</a> and the <a href="#extensions-c-like-string-juxtaposition">C-like string juxtaposition extension</a> regardless of the options passed in the command line:</p>

<pre><code><span>#pragma OPT +BreakCont,+AllowMultiStrings</span>
<span>default</span>
<span>{</span>
<span>  while (TRUE) break;</span>
<span>  llOwnerSay("TEA" "TIME");</span>
<span>}</span>
</code></pre>

<p>Like in the command line, prepending a <code>+</code> sign or not preprending anything to an option has the same effect, namely to activate the option, while prepending a <code>-</code> sign has the effect of deactivating the option.</p>

<p>The list of options usable in <code>#pragma</code> directives is:</p>

<pre><code><span>ExtendedGlobalExpr</span>
<span>ExtendedTypeCast</span>
<span>ExtendedAssignment</span>
<span>ExplicitCast</span>
<span>AllowKeyConcat</span>
<span>AllowMultiStrings</span>
<span>ProcessPre</span>
<span>EnableSwitch</span>
<span>BreakCont</span>
<span>ErrMissingDefault</span>
<span>LazyLists</span>
<span>DupLabels</span>
<span>ShrinkNames</span>
<span>FuncOverride</span>
<span>Inline</span>
</code></pre>

<p>For a description of each, you can invoke the program from the command line with: <code>python main.py -O help</code> (that's the upper case letter O, not the number zero). Note, however, that the only options that can be used in <code>#pragma</code> directives inlined in the code are the options listed above, which are the ones that affect the parsing, not the optimization.</p>

<p><b>Important:</b> Changing options in the middle of the program may not be well supported. In particular, activating and deactivating in the same program certain options like <code>BreakCont</code> may crash the optimizer. Changing the options at the beginning of the script should be safe.</p>

<p><i><b>Note:</b> <em>GNU cpp</em> actually generates a preprocessor command that only contains the line number and the file name, pretty much like a </i><code>#line</code><i> directive does, but without the </i><code>line</code><i> part. The parser deals with that format correctly, treating it as if it was a </i><code>#line</code><i> directive.</i></p>

<p><i><b>Note:</b> Firestorm prepends a <em><code>//</code></em> comment to the </i><code>#line</code><i> directives that <em>Boost::Wave</em> generates; since the optimizer doesn't use Firestorm's output directly, it doesn't interpret these lines specially.</i></p>

<p><i><b>Note:</b> Pragma operators of the form </i><code>_Pragma("pragma string")</code><i> introduced in <em>C99</em> are not supported.</i></p>

<p>In versions 0.1.3alpha and below, there was a similar option called <code>skippreproc</code> that merely skipped any preprocessor directives. That option is now removed.</p>

<h3><a id="extensions-inlining"></a>Manual inlining of functions</h3>

<p>The option <code>inline</code> in the command line options enables a syntax extension that allows you to use functions as if they were macros. This option is disabled by default, due to its effect on While and For loops.</p>

<p><b>This feature is in an experimental stage. Use at your own risk.</b></p>

<p>To declare a function as inline, add the word <code>inline</code> after the close parenthesis of the parameter list. For example, this definition:</p>

<pre><code><span>say(string s) inline</span>
<span>{</span>
<span>    llOwnerSay(s);</span>
<span>}</span>
</code></pre>

<p>allows you to use <code>say</code> as if it were <code>llOwnerSay</code>, without actually defining a new function in the optimized output. Of course, the same can be done with a preprocessor macro.</p>

<p><b>Caveats:</b></p>

<ul>
<li>It's still possible that the resulting code ends up wasting more space than defining a function. Preprocessor macros may be preferable.</li>
<li>The order of evaluation of functions may not be the same as without inlining. All inlined functions will be executed before the expression they are used in, in an unspecified order. This order may change in future, so don't depend on it.</li>
<li>New labels and variables may be created. The names use the pattern <code>___letters__numbers</code>. If you use names like these, you risk causing a name collision.</li>
<li>While and for loops will always be transformed in the output to labels and jumps.</li>
</ul>

<hr>

<h2><a id="compatibility-syntax-extensions"></a>Compatibility Syntax extensions</h2>

<p>These extensions are implemented for compatibility with the syntax extensions originally integrated in Emerald and currently in Firestorm. Their use is discouraged and they are considered legacy extensions.</p>

<h3><a id="extensions-switch-statements"></a><code>switch()</code> statements</h3>

<p>Enables use of C-like <code>switch</code> statements. These produce very awkward code, hard to optimize, and the argument is evaluated multiple times (as many as <code>case</code> labels are present).</p>

<p>The syntax of the <code>switch</code> statement as implemented, has two restrictions over its C counterpart:</p>

<ol>
<li><code>case</code> labels can't appear in nested blocks. That's because they are replaced by LSL labels, and as discussed in the <em>Multiple labels with the same name</em> section above, label scope rules prevent their visibility in an outer block, so once converted to labels, the corresponding <code>jump</code> instructions would not be able to find them. This limitation means that <a href="https://en.wikipedia.org/wiki/Duff's_device">Duff's device</a> or similar constructs can't be implemented with this optimizer.</li>
<li><div><code>switch()</code> needs to be followed by a block, not by a single statement. For example, while this works in C, it won't work in this optimizer:</div>
<pre><code><span>    switch(1) case 1: break;</span></code></pre>
<div>The reason is that <code>case</code> is treated by this parser as a statement, rather than as a label prefix, making <code>break</code> be outside the <code>switch</code> and thus failing at that point. This limitation is probably only of theoretical importance and will not have any practical implication, since single-statement <code>switch</code> clauses are of little or no practical use (known to the author). Of course it works perfectly when enclosed in braces:</div>
<pre><code><span>    switch(1) { case 1: break; }</span></code></pre></li>
</ol>

<p>As an extension, and for compatibility with Firestorm, if there is a block beginning right after a <code>case</code> or <code>default</code> statement, the colon is optional. For example, all these are valid:</p>

<pre><code><span>    switch (x) { case 1: ;  default: ;  } // normal syntax</span>
<span>    switch (x) { case 1: {} default: {} }</span>
<span>    switch (x) { case 1  {} default  {} } // extended syntax</span>
</code></pre>

but this will cause an error:
<pre><code><span>    switch (x) { case 1  ;  default  ;  }</span>
</code></pre>

<h3><a id="extensions-lazy-lists"></a>Lazy lists</h3>

<p>That's how Firestorm calls an extended syntax for subindex values referencing individual list elements.</p>

<h4><a id="lazy-lists-assignment"></a>Assignment</h4>

<p>The syntax for assignment is:</p>

<pre><code><span>mylist[index] = value;</span>
</code></pre>

<p>which is designed to be roughly a shortcut for this:</p>

<pre><code><span>mylist = llListReplaceList(mylist, (list)value, index, index);</span>
</code></pre>

<p>The implementation, however, includes creating a function that performs the replacement, which prevents the index from being evaluated twice but also uses more memory. The function is called <code>lazy_list_set</code>. It can be user-overriden. If you define a function with this prototype:</p>

<pre><code><span>list lazy_list_set(list target, integer index, list value)</span>
</code></pre>

<p>which returns the list with the element replaced, then the optimizer will use yours rather than defining it twice. Note that a preprocessor macro won't work in its place.</p>

<p>For compatibility with Firestorm, when the index is greater than the number of elements in the list, the intermediate values are filled with integer zeros. If you don't want that, you may have a reason to override it.</p>

<p>Note that the value of the assignment as an expression is the whole list, not the element. For example, this will fail because it's assigning a list to an integer:</p>

<pre><code><span>  list a;</span>
<span>  integer b = a[5] = 4;</span>
</code></pre>

<p>To see why, look at what that is expanded to:</p>

<pre><code><span>  list a;</span>
<span>  integer b = a = lazy_list_set(a, 5, (list)4);</span>
</code></pre>

<p>which will obviously fail. But this will work:</p>

<pre><code><span>  list a;</span>
<span>  integer b;
<span>  a[5] = b = 4;</span>
</code></pre>

<h4><a id="lazy-lists-reading"></a>Reading</h4>

<p>The syntax for reading an element is the same as for assigning, but it returns no type, therefore a type cast is mandatory. For example:</p>

<pre><code><span>  list a;</span>
<span>  integer b = (integer)a[3];</span>
</code></pre>

<p>That is converted at parsing time to:</p>

<pre><code><span>  list a;</span>
<span>  integer b = llList2Integer(a, 3);</span>
</code></pre>

<p>If the type it's cast to is list, it needs two parameters (starting and ending index), not one:</p>

<pre><code><span>  list a;</span>
<span>  a = (list)a[3, 3];</span>
</code></pre>

<p>That is a requirement of the underlying <code>llList2List</code> function used in this case.</p>

<h3><a id="extensions-allow-dup-fn"></a>Allow duplicate function definitions</h3>

<p>If two or more functions with the same name are defined, the latest definition takes effect. This is done for compatibility with Firestorm; apparently that "feature" is used by some people.</p>

<p>Note that Firestorm also allows calling undefined functions, as long as the function that has the calls is optimized out. That feature is not implemented by this optimizer, as it would complicate expression parsing a lot. It's also considered a misfeature; writing code that relies on it is discouraged.</p>

<hr>

<h2><a id="optimizations"></a>Optimizations</h2>

<h3><a id="optimizations-constant-folding-and-expression-simplification"></a>Constant folding and expression simplification</h3>

<p>The optimizer simplifies expressions as much as it knows, which is a fair amount, though there's still room for improvement in this area. Expressions that evaluate to a constant will be replaced with that constant. Most calculation functions are implemented; note, however, that the JSON functions in particular do not follow the broken LSL behaviour too closely, and that <code>llJsonSetValue</code> in particular is not implemented as of yet.</p>

<p>Other expressions such as a+3+1 are replaced with a+4, and so on. Note, however, that for floats, <code>(a+b)+c</code> may not equal <code>a+(b+c)</code>, so that optimization is not always done for floats. Also, as of this writing this optimization is only partial, so some expressions may not be optimized, e.g. <code>2+a+b+3</code> is not optimized to <code>a+b+5</code>. Many boolean expressions are simplified too (more are on the way). For example, <code>(TRUE&amp;&amp;(expression))</code> is simplified to <code>(expression)</code>, and <code>(FALSE&amp;&amp;(expression))</code> is simplified to <code>(FALSE)</code> provided the expression has no side effects. The famous <code>if (llListFindList(...)!=-1)</code> to <code>if (~llListFindList(...))</code> replacement is also performed automatically.</p>

<p>The constant folding optimizer is also responsible for simplifying certain statements, e.g. <code>if (FALSE) { statements; }</code> is completely removed, and <code>if (TRUE) { statements1; } else { statements2; }</code> is replaced with just <code>{ statements1; }</code>, removing <code>{ statements2; }</code>. The <code>do...while(constant)</code> loops and other loops are optimized similarly.</p>

<p>This enables using many preprocessor tricks, like creating an <code>assert()</code> macro similar to that in C:</p>

<pre><code><span>#define assert(...) do { if (DEBUG) if (__VA_ARGS__) ; \</span>
<span>  else llOwnerSay("ASSERTION FAILED: " #__VA_ARGS__); } while (0)</span>
</code></pre>

<p>without worrying about the extra memory that it will take in production code once DEBUG is switched off, or about the loop taking up actual code memory.</p>

<h3><a id="optimizations-dead-code-removal"></a>Dead code removal</h3>

<p>This part of the optimizer tracks execution and usage of statements and variables, removing the ones that aren't used. It performs a function similar to that of the Firestorm optimizer, but it can remove also unused locals and dead code after a <code>return</code> or <code>jump</code>, and isn't confused by having a global and a local with the same name.</p>

<p>It also replaces references to integer, string and key variables that are not written to (global or local), with their value. For example:</p>

<pre><code><span>integer ANSWER = 42;</span>
<span>default</span>
<span>{</span>
<span>    state_entry()</span>
<span>    {</span>
<span>        llOwnerSay((string)ANSWER);</span>
<span>    }</span>
<span>}</span>
</code></pre>

<p>will produce:</p>

<pre><code><span>default</span>
<span>{</span>
<span>    state_entry()</span>
<span>    {</span>
<span>        llOwnerSay("42");</span>
<span>    }</span>
<span>}</span>
</code></pre>

<p>after DCR and constant folding. This optimization has one of the largest impacts, as variables and parameters in general seem to take a lot of memory in Mono, and removing as much of them as possible produces good savings.</p>

<h3><a id="optimizations-shrinking-identifiers"></a>Shrinking Identifiers</h3>

<p>Long variable and parameter names are nice and readable, but when used as part of the globals or as function parameters, or in function or state names, each character in the identifier takes at least one byte of code memory. In large programs, this can add up to a significant amount. This option replaces global (including functions and states) and parameter identifiers with the shortest possible ones, also reusing as many as it can as well as reusing some system ones. The savings from this alone can be very significant in programs with a large number of globals or states.</p>

<h3><a id="optimizations-floats"></a>Floats</h3>

<p>Floats under Mono are internally double precision, so float constants take four more bytes than integers. On the other hand, type cast from integer to float takes only one byte. This optimization substitutes floats with integers where possible, for an overall saving of three bytes per number. For example, it transforms <code>llSetTimerEvent(0.0)</code> into <code>llSetTimerEvent(0)</code>.</p>

<h3><a id="optimizations-signs"></a>Signs</h3>

<p>The sign at the beginning of a number constant (except in globals) takes up one byte of code, unless prefixed by a type cast (which does not, under Mono, take up code memory by itself if the destination type is the same). Small saving, but it adds up to the overall. Numbers are thus output with a type cast and surrounded by parentheses, e.g. <code>((float)-1.5)</code> instead of <code>-1.5</code>.</p>

<h3><a id="optimizations-string-constant-folding"></a>String constant folding</h3>

<p>This optimization is turned off by default, as it can be counter-productive. It enables concatenating string constants together. However, consider this situation:</p>

<pre><code><span>string a = "A very long string that appears in this script once" + ", or not";</span>
<span>string b = "A very long string that appears in this script once" + " or twice";</span>
</code></pre>

<p>Since Mono keeps only one copy of each constant string in the code, making the optimizer concatenate them would be counter-productive, generating two long strings that would take more code than the original string plus the shorter ones.</p>

<hr>

<h2><a id="using-the-program"></a>Using the program</h2>

<p>This program is designed to work as a filter. It can read from standard input if the file name argument is "-", and it can (and does by default) output the result to standard output. Any errors and warnings go to standard error always, to not interfere with the script being output.</p>

<p>The input script must be encoded in UTF-8. If you're using an editor, make sure it saves UTF-8.</p>

<p>Running it by hand to optimize your scripts can be cumbersome. The intention is for it to act as a filter that is transparent to the user; however, as of this writing there's no support for any viewer or IDE. Run it without parameters to see the invocation help, for example with <code>python main.py</code>. Redirect the output to a file if you want to store the result, possibly to open it with an editor and copy it to the clipboard. Or under <em>X Window</em>, if you install the package <kbd><em>xclip</em></kbd>, you can pipe the output directly to <code>xclip -quiet -selection clipboard</code> to copy it to the clipboard, rather than using a file, so you can paste it into the viewer. It's a good idea to use the option <code>--bom</code> to include a UTF-8 byte order mark that other applications can use to recognize the encoding. Examples:</p>

<pre><code><span>python main.py --bom myscript.lsl | xclip -quiet -selection clipboard</span>
</code></pre>

<p>will, under <em>X Window</em>, read <code>myscript.lsl</code>, optimize it, and copy the optimized result to the clipboard, ready to be pasted into the viewer.</p>

<pre><code><span>python main.py --bom myscript.lsl -o temp.opt</span>
<span>notepad temp.opt</span>
</code></pre>

<p>will, under any system which has an editor called <code>notepad</code>, read <code>myscript.lsl</code>, optimize it, and write the optimized result to <code>temp.opt</code>, then open it in the editor, enabling you to copy it and paste it into the viewer. Under <em>Windows</em> version <em>Vista</em> and above, there's a command line application called <code>clip</code> that does the same as <code>xclip</code> does for <em>X Window</em>, enabling you to use this:</p>

<pre><code><span>python main.py --bom myscript.lsl | clip</span>
</code></pre>

<p>to copy the optimized output to the clipboard. Under <em>OS X</em>, <code>pbcopy</code> does the same as <code>xclip</code> and <code>clip</code>.</p>

<p>The <code>clip</code> application does not recognize the byte order mark, therefore <em>Windows</em> users may need to execute <code>chcp 65001</code> before using the optimizer, to switch their console to UTF-8 and make the <code>clip</code> program work properly with non-ASCII characters.</p>

<p>An external preprocessor is supported. If your system has a GNU C Compiler suite already installed, then the <code>cpp</code> that comes with it (or <code>gcc</code> adding the <code>-E</code> option) should be enough. If you don't have it, the recommended preprocessor is <em>mcpp</em>, because it's a standalone executable, easy to install. Download it from <a href="http://mcpp.sourceforge.net/download.html">http://mcpp.sourceforge.net/download.html</a>, unpack the executable somewhere in the system path (or specify the path to the executable every time with the <code>--precmd</code> option of the program) and you're ready to go.</p>

<p>Future plans include writing a patch for Firestorm to enable it to run external script filtering programs instead of Firestorm's internal preprocessor and optimizer. That would allow this program to be run using Firestorm's integrated machinery, making usage pretty transparent to the programmer.</p>

<p>Support for other IDEs like Eclipse is not planned, but the author encourages others to write it. Please notify Sei Lisa if you write one, so that it can be listed in this page.</p>

<p>The program uses two external files. One is <code>builtins.txt</code>, which is in the same format as needed by <a href="https://github.com/makopo/lslint"><em>lslint</em></a>, and an up-to-date copy can be obtained from the <a href="https://bitbucket.org/Sei_Lisa/kwdb/"><em>kwdb</em></a> project: <a href="https://bitbucket.org/Sei_Lisa/kwdb/raw/tip/outputs/builtins.txt">https://bitbucket.org/Sei_Lisa/kwdb/raw/tip/outputs/builtins.txt</a>. The other is <code>fndata.txt</code>, which is a list of LSL functions and events, with some data related to the semantics of each of them, so the optimizer has the possibility of applying more optimizations that are particular to them.</p>

<hr>

<h2><a id="other-future-plans"></a>Other future plans</h2>

<p>Making the optimizer smarter is one primary objective. Conversion to <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> form is currently not performed, and would be nice to have, for one, to enable more optimizations where values are not used. There are a number of TODO items in the code about optimizations pending to implement.</p>

<p>Lastly, implementation of some kind of machine-readable way to inform the invoker about the available options, is also in the plans. That would allow the plugin or viewer or whatever to present a dialog with the options for invoking the optimizer.</p>

<hr>

<h2><a id="license"></a>License</h2>

<p>This program is distributed under the terms of the GNU General Public License (GPL) version 3.</p>

<p>&copy; Copyright 2015-2024 Sei Lisa. All rights reserved.</p>

<p>Just to put it explicitly, processing code with this optimizer does NOT automatically make the result fall under the terms of the license. Only the optimizer itself is subject to the terms of the GPL, similarly to how the C code compiled by a GPL-licensed compiler is not subject to the licensing requirements of the compiler even if the compiler itself is.</p>

<p>When using lazy lists, a fragment of code (a small function called <code>lazy_list_set</code>) may be included in the output. This function, written by Sei Lisa, is in the public domain and is therefore not subject to any copyright restrictions.</p>

<h2><a id="author"></a>Author</h2>

<p>Written by Sei Lisa. Sei Lisa is the author's pseudonym and user name in the Second Life virtual world.</p>

<hr>

<p>Happy coding!</p>

</div>
<div style="margin-left:7%">(Ever wondered why do people do these things?)</div>
</body></html>
